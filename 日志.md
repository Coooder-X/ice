# 日志

### 7.3

*   [x] 读 RSC 的 RFC 以及文档
    
*   [x] 理解 server-components-demo
    
*   [ ] 弄懂 SSR 是如何在 server 跑起来的，可以参考 ice
    
*   [x] 归纳问题
    

### 7.4

todo:

*   [x] 完善 RSC 知识和细节
    
*   [x] 运行 server-components-demo
    
*   [x] 理解 server-components-demo
    
*   [x] 从运行时和构建时了解 next 和 react-demo 的 RSC 怎么做的
    

问题：

*   [x] RSC 在后端编译时，RCC 是会编译出单独的文件，前端拿到后端返回的 RSC 组件树后进行解析，如果遇到 RCC，则再向后端请求 RCC 的 chunks，这是否也算是一种懒加载，来减小一次性传输的大小？
    
*   [ ] ![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/NpQlKzzez4zLODvL/2144406d-2695-4f4a-aac8-f9ce18db245f)
    
*   [x] RSC 中的 json 解析格式，即 @、S 那些，是 RFC 标准里的吗，还是 react 自己的实现，next 中是怎么实现的？
    
    *   [ ] 需要找到序列化的具体规则文档
        
*   [ ] 如何调试 webpack 的插件，或者 npm run 起来的node服务
    
*   [x] RSC 比 CSR 快在哪里，是服务端渲染-客户端渲染的时间吗，但 RSC 不是可能还要再请求 RCC 的 bundle 吗
    

### 7.5

todo：

*   [x] 读4号看到的文档博客
    
    *   [x] [https://juejin.cn/post/6918602124804915208](https://juejin.cn/post/6918602124804915208)
        
    *   [ ] react RFC，序列化部分 ​RFC：[https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#simplified-loading-sequence](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#simplified-loading-sequence) ​ReactFlightServer.js [https://github.com/facebook/react/blob/42c30e8b122841d7fe72e28e36848a6de1363b0c/packages/react-server/src/ReactFlightServer.js#L368](https://github.com/facebook/react/blob/42c30e8b122841d7fe72e28e36848a6de1363b0c/packages/react-server/src/ReactFlightServer.js#L368) blog ​https://www.plasmic.app/blog/how-react-server-components-work
        
*   [ ] 整理出 RSC 的流程图，包括构建时和运行时的
    
    *   [x] 运行时，以开发者角度看懂 react 的 demo，大概就能明白了
        
    *   [x] 在 client 修改数据后，RSC 要如何更新组件？
        

​ans：还是通过 /react 接口向服务端请求，服务端重新渲染返回 json

*   [ ] server 返回的可以不是 json，而是 html 吗
    
*   [ ] json 要分隔成 chunks 发给客户端，这个 chunks 是![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/fd60bffb8d594ed99ef28adc8dbeab5e3180.png)和![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/7c2c76f9fce548dd9e5b818eb78ad9513180.png)吗，它们按一定的优先级发送，这里顺序是一样的
    
*   [ ] 它的分隔机制怎么实现
    

*   [x] Root.client.js 起什么作用，就是第一次请求 /react？
    
*   [x] demo 是有一个 root RSC，它负责请求 /react 获得 json，但抛开 demo，是不是通过传不同的 router 获得不同页面的 json？如果是在首屏，和 SSR 结合？如何结合？
    

客户端通过 route1 请求，SSR 服务返回了一个 html，html 中包含（怎么包含？）一个 root RCC，这个 RCC 发送 route2 请求 RSC 的 json

*   [ ] hydrate 的具体概念，对应代码哪里，是怎么做的
    
*   [ ] next 的 demo 在哪
    
*   [ ] 稍微对比下 next 的实现
    
*   [ ] SSR 的服务是如何起来的，RSC 能共用同一个吗（是共用一个），CSR 应该怎么办
    
*   [ ]  SSR 结合的 RSC，SSR 返回 path1的 html，其中遇到 RCC（可以看做demo里的 root client），则请求 path2 得到 json，如何渲染，验证下是不是这样。如果是 CSR 呢，是不是因为没有SSR的服务端，但仍然是通过一个 root client 请求 json，但需要自己新起一个服务端？
    

### 7.6（读插件源码）

*   [x]  ![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/0736e4d70abb4ff0870ccaad40d878403180.png)
    

这里新的一次请求，json 里面多了 M5，则返回的 chunks 里面多了两个 js。（这里查看 json 里面有哪些 chunks 并找到文件发给 client 的逻辑是服务端实现的吧？在哪）

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/f0fadb8b91494a35a8472eed29f20ef13180.png)

第一段绿色代表 /react 的请求返回了 json，重合的2、3段代表下面两个 js 同时到达（是服务端主动给的还是客户端请求的？）

*   [ ] 如我理解的，react 官方 demo 的方法是先有一个 root RCC，它发送一个 url 请求服务端给 RSC 的 json。看看 next 是不是这么做的？
    
*   [ ] 客户端重新请求 RSC 的时候，服务端有进行类似 diff 的环节吗
    
*   [x] RSC 减少的了首屏的 bunble 大小，那服务端如何知道打包首屏的 bundle 时应该排除哪些 bundle？有一个清单，这个是不是 manifest？
    

/build/react-client-manifest.json

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/0f4184e791c24a26a88a1f08fcfeda793180.png)

*   [ ] RCC 中的交互导致 RSC 变化，需要如何通知变化，再请求一次吗
    
    *   [ ] 再请求一次，所有 chunks 重新发一遍，很浪费？
        
*   [ ] json chunks返回时，RCC的 js 文件也返回了，但是返回 js 的逻辑在哪？
    

### 7.11 

*   [x] 基本读懂官方demo源码
    
*   [x] 开始看 next 源码
    

### 7.12

*   [x] 搞懂 RCC 交互式怎么导致 RSC 更新的
    
*   [ ] 搞懂 ice 的最终方案里 root client 要怎么获取数据，如果不是手动请求，怎么才能封装到底层
    
*   [x] 梳理 next 的实现
    
*   [x] 修复官方 demo
    

### 7.13

*   [x] 大致了解官方 demo 的 RSC 依赖版本和 next 的版本的区别
    
*   [x] 周会分享
    

### 7.14

*   将官方 demo 的依赖更新为新版本的，并尝试 build
    
    *   新旧版本 webpack 版本不同，需要换新的，换完 build 报堆栈溢出
        
    *   尝试用 react 官方 github 的代码，但需要 build 一下
        
        *   build 报错，需要装 java
            

### 7.17

*   新版本插件构建尝试成功
    
*   了解 ice 代码结构，关键的几个目录，新建 example
    
*   新增 rsc 参数，通过 ejs 传入成功
    

### 7.18

*   添加 react-server-dom-webpack 插件，能够扫描项目目录，检测 use client 关键字，但是没法产生 manifest
    
*   阅读插件源码
    
*   知道是在客户端代码中没有引入 react-server-dom-webpack/client 函数导致没有依赖图中没有这个模块，所以插件后续逻辑无法进行
    

### 7.19

*   客户端代码中引入了  react-server-dom-webpack 模块，但是还是无法在依赖模块中检查到
    
*   阅读 ice 代码，了解了 .ice 目录生成的逻辑
    
*   发现是由于 react-server-dom-webpack 模块不是使用 esm 方式，而 ice 是，因此引入失败，更改了引入方式即可
    
*   (由于忽略了 pnpm run setup，所以很久才发现问题。在 setup 后才给出提示说引入方法有问题，而没有 setup 时虽然代码引入了模块，但实际上并没生效，所以没发现)
    
*   输出 manifest 还是有问题，不知道是不是和其他的构建打包有冲突，还是插件调用顺序的问题
    
*   下一步是了解 devserver 的逻辑，以及如何添加逻辑
    

**最终 createFromFetch 等引用不应该由用户引入，可以放到 .ice 文件中引入再导出**

*   sb 了，只 run start 了，所以那些 bundles 都在内存没有生成到目录，所以才一直没有manifest 出现，浏览器 source 里是有 bundlle 的。只有在 run build 的时候才会生成到目录，我拿 domo 项目尝试成功的原因就是我 run build 了，但是没意识到这里的差别。。。还是对 webpack 运行和构建的基础缺失导致的。。。
    
*   开始看 server 侧的逻辑，应该在哪里加 ​看：
    
    *   start.ts 
        
    *   renderMidWare.ts
        
    *   createService.ts
        
    *   runServerApp.ejs
        
    *   gegerate Entry
        

### 7.25

*   runServerAPP renderToHTML 函数里，判断了输出类型是 js 还是 html，是否加一个 json？
    
    *   renderToEntry 函数是已经获取到了请求返回到数据，再进行 render 的过程，应该去请求的地方看看？
        
    *   假如这里返回了 RSC 的 response，则这里加一个类型判断和 render 方法？
        
*   RSC 请求的参数和请求写在哪里？
    
*   先只考虑 CSR 的情况，其他情况跳过不看
    
*   打包的时候能不能忽略或者不生成插件的 ssr manifest
    
*   运行时是不是和 route 有关系，要不要改 renderMidleware 里 routeManifest 的逻辑？
    
*   excuteServerEntry
    
*   应该是在 ClientRouter.tsx 里面改
    

### 7.26

*   初步加入了 rootclient 的入口
    
*   初步加入了 renderRsc 的后端代码
    
*   尝试加入 RSC 的 api，处理序列化和反序列化，兼容旧的渲染逻辑
    

cjs 和 esm 的模块引入方式

/server.browser 和 /server.node 有啥区别

readable 和 pipeable 两个函数有什么区别

### 7.27-7.28

*   renderRsc 的后端代码加入，一开始不知道怎么像 demo 一样引入 serverRoot 组件，因为运行提示不在 react-server 环境，后来发现应该要和 ssr 一样，通过传入的 Document 获得组件树。然后修改，确实应该是可行的，但 start 报错，是 server-dom-webpack 里的莫名其妙的地方报的，看不出问题
    

> if (ReactCurrentCache.current !== null && ReactCurrentCache.current !== DefaultCacheDispatcher) {

>                         ^

> TypeError: Cannot read properties of undefined (reading 'current')

*   ![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/7b5ecac64f7f46b3a5f65a8121b7657c3180.png)
    

rsc-touter.tsx，这里验证了下，如果是 <div>123</div> 是可以展示在页面的。如果换成下面这部分则没有展示任何内容，但上方 createFromFetch 是有执行的，fetch 也发送了![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/f1ae1d6e2d07457782b0026584c9fdf83180.png)

只不过可能内容并不是想要的，这里应该是返回序列化的 json

*   那么问题来了，这个请求发到哪 http://localhost:3000/app?location=%7B%22param%22%3A%22param%22%7D  这个是请求 url，但是应该是给 devserver，devserver 向 apiServer 请求数据，得到后再进行序列化
    
*   尝试先不考虑 第一次请求 rsc 的时候去获取数据，而是直接返回一个确定的 json。经过调试，发现第一次的 localhost 请求是正确的，请求得到了一个 html ![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/baef740a6ac84df1b1f06692702738983180.png)
    

在执行这个 html 里的 js 时，发起了 clientEntry 发的 /app?location=xxx 的请求，这个请求应该返回的时 json，然而返回的是和第一次一样？的 html。debug 发现两次请求都走的 ![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/bc8d428d288645358d6a257ebb4bf6313180.png)

第 307 行的 renderDocument。在第一次请求 localhost 时，走这里时对的，但是第二次请求 /app？location 时就应该要走上面那个 useRsc 里的逻辑。这里应该用是吗判断，来分开这个逻辑？

光知道时 rsc 的请求还不够，应该要知道是请求 json 的还是请求第一个 html 的。

*   另一条线的问题，是直接打开这段注释后，renderToPipeableStream 中的 createRequest 会报错 currenReactCache 为 undefined。不知道是不是第一次进来应该请求 html 但却走了序列化逻辑的原因？先解决上面一个点的问题，再看这个
    

### 7.31

basic ssr:

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/63043b55a44b48598e2c34d1dcaa985f3180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/63523001220b4824bd18c1aa4603e2c63180.png)

rsc:

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/4a0bdf1792b64c2e98fb3f917e49eacc3180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/cd9af05eddc94fd98d7191a450c8d4413180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/44942475b188400287c33edf7a2f0bdb3180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/954dafed2578494782ba9dfb1927571a3180.png)

修改之前配置的代理，并启动 api server：

    export default defineConfig(() => ({
      publicPath: '/',
      webpack: (webpackConfig) => {
        if (process.env.NODE_ENV !== 'test') {
          webpackConfig.plugins?.push(new SpeedMeasurePlugin());
        }
        return webpackConfig;
      },
      crossOriginLoading: 'anonymous',
      proxy: {
        '/': {
          target: 'http://localhost:4000/',
          changeOrigin: true,
          pathRewrite: { '^/' : '' },
        },
      },
      dropLogLevel: 'warn',
      plugins: [
        auth(),
      ],
      eslint: true,
      ssr: false,
      ssg: false,
      rsc: true,
    }));
    

api server:

    import express from 'express';
    import { readFileSync } from 'fs';
    import path from 'path';
    // import { renderToHTML } from './build/server/index.mjs';
    
    const app = express();
    const port = 4000;
    // const basename = '/app';
    
    app.use(express.static('build', {}));
    
    app.get('/app', (req, res) => {
      console.log('/app-------------')
    })
    
    app.get('/api', (req, res) => {
      console.log('/api-------------')
    })
    
    app.get('/', handleErrors(async function(_req, res) {
      // await waitForWebpack();
      const html = readFileSync(
        path.resolve(__dirname, '../build/index.html'),
        'utf8'
      );
      console.log('/-------------')
      res.send(html);
    }))
    
    app.get('/rsc', handleErrors(async function(_req, res) {
      console.log('/-rscrsc-------')
    }))
    
    app.listen(port, () => {
      console.log(`App listening on http://localhost:${port}`);
    });
    
    function handleErrors(fn) {
      return async function(req, res, next) {
        try {
          return await fn(req, res);
        } catch (x) {
          next(x);
        }
      };
    }

不对，这里不可以开代理连 api server，实际逻辑是走中间件，中间件处理请求，从 devserver 发请求去 api server，所以也不用管跨域和代理

但问题是 devserver 如何发送请求到 api server，api 的端口在哪里设置的，api server 的逻辑怎么写，返回什么数据？

devserver 在 start.ts 里初始化和创建，那么 devserver 里的逻辑是在 中间件里吗

后来发现 reactCurrentCache 是 react18.3 的版本的，而项目里是 18.2，因此升级应该能解决问题。升级后发现 react-server-dom-webpack-plugin 在扫描打包时找不到客户端代码对 react-server-dom-webpack 的引用了，在插件中打印 modules.resource 和 clientFileName 信息发现依赖路径对不上，主要是因为不同目录都有 react 的依赖而且版本不同，就是刚刚升级导致的。所以在 webpack 中配置 alias，将 react-server-dom-webpack 的依赖都指向客户端代码中需要的 react-server-dom-webpack/client.browser，于是解决问题

### 8.1

在服务端序列化时，出现报错，指示有服务端组件给客户端组件传了 function，不可序列化。发现时给 document 里传了 route.lazy，这个函数在 /Users/lzx/Documents/project/ice/packages/ice/src/routes.ts 中生成，在 /template/core/routes.tsx.ejs 中执行打包时给项目的 @ice 目录的 routes.tsx 生成产物。看看时在哪里修改，让 rsc 的场景下 lazy 不生成？

上面的想法不对，在rsc的情况下应该就不需要这样控制router，而是自己处理router

现在的问题是：项目里的 html 模版是 document.tsx ，传给了 runserverApp 的 renderToResponse 渲染，但 rsc 还需要传入一个 serverComponent，从哪里传？

### 8.2

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/01b10404b26048f8a79c9d3ec83185963180.png)

Warning: Only createServerContext is supported in Server Components.

TypeError: Cannot destructure property 'appConfig' of 'useAppContext(...)' as it is undefined.

    at App (file:///Users/lzx/Documents/project/ice/packages/runtime/src/App.tsx:7:11)

Warning: React elements are not allowed in ServerContext

Warning: Only createServerContext is supported in Server Components.

### 8.3

尝试：在官方demo验证传函数

把ice里的函数都去掉传

### 8.4

createServerContext 的 使用是不是和 createContext 一样，我的改动能不能用

尝试 serverContext 能不能传函数，不能看看能不能把 route 传参放到 client 组件

在 runServerApp 里到底是怎么判别 RSC 和 RCC 的？![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/0dbd53fba56342c797f76ff5c2b906d43180.png)这样也不行，appContext里包含了函数

### 8.7

### 8.8

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/68398eda384946ceb00d27eb0b3aafbd3180.png)

1、如果只写第二行的 DocumentContextProvider，则调用了 ServerRoute 和里面的函数 成功，里面的输出执行了，但由于没有 appContext 报错 

2、如果第一行也加上，则报错 RangeError: Maximum call stack size exceeded，是在插件的报错处理中的报错

3、AppRouter 加不加都一样，被第二点的报错拦住了

4、如果只写 div 这行，则正常渲染不报错

实现思路：因为 routes 包含函数，routes 是根据 routeManifest.json 拼接生成的，所以可以传 json，在客户端组件里进行转换成 routes。

完成了转换逻辑，但还是报不能传 function 的错，猜测可能是 AppRouter 这个组件不是写在客户端的，被认为是服务端组件，所以即使在此把 json 转 routes，仍然不是在客户端组件里。（是不是可以放在 ice 里，拼接转换的函数 import 进来？）

另一个问题是 <AppContextProvider value={{...appContext, routes: null}}>只要出现，始终会报 RangeError: Maximum call stack size exceeded（重点看下源码）

### 8.9 

### 8.10

只打开 appContextProvider，是可以的，返回了 json，不过不知道 1:"$Pnull" 有没有问题

    1:"$Pnull"
    0:["$","div",null,{"children":["$","$1",null,{"value":{"appExport":{"default":{}},"routes":null,"appConfig":{"app":{"strict":false,"rootId":"ice-container"},"router":{"type":"browser"}},"appData":"$undefined","loaderData":{},"renderMode":"SSR","assetsManifest":{"publicPath":"/","entries":{"main":["js/framework.js","js/33be4d65.js","js/vendors-node_modules_pnpm_core-js-pure_3_29_0_node_modules_core-js-pure_features_global-this_-35a36d.js","js/main.js"]},"pages":{"client1":["js/client1.js"],"client2":["js/client2.js"],"client3":["js/client3.js"],"client4":["js/p_blog.js"],"client5":["css/client5.css","js/client5.js"],"client6":["js/client6.js"],"client7":["js/client7.js"],"client8":["js/client8.js"],"layout":["js/client6.js"],"about":["js/client3.js"],"index":["css/client5.css","js/client5.js"],"blog":["js/p_blog.js"]},"assets":{"src/pages/ice.png":"971eddfc"},"dataLoader":"js/data-loader.js"},"basename":"/","matches":[],"requestContext":null,"serverData":"$undefined","RouteWrappers":[]},"children":"$undefined"}]}]
    
    

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/24aa1c8dd6cb47f1993840adcb88b95b3180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/4416eef9de474c9891b3020c1ff230a83180.png)

#### 问题：

问题1: rscServerRouter 里，把序列化 manifest 转成对象的地方有问题，生成的 routes 是空

sb！！！import 里必须是字符串，不可以是动态拼接的变量，明明是知道的，查了百度确认了，但是在代码里没意识到。

所以 应该把文件路径映射写到一个文件里，在这个组件读，而不是在这里拼接

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/5cf184fd95604fe2a7c63fe4e03fca7a3180.png)

问题2：还是这个文件，createStaticRouter 函数的返回里是有函数的，应该是符合预期的，因为按理说是在当前 client 组件里面拼接的，传给下层 client 组件没问题，但是还是报错不能传函数，所以why？？

import 里面不能包含变量，必须是字符串！！

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/NpQlKzzez4zLODvL/8b618a9e-655f-4ea7-af94-1774c125ca43)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/NpQlKzzez4zLODvL/a2fbfea1-bc13-464f-8a3f-380a382b1fe0)

问题3: formatPath 函数，里面 关于 process.platform 的判断。客户端代码是没有 process 的

### 8.11

*   问题1:
    

import 里面不能包含变量，必须是字符串，所以在 client 组件 rscServerRouter 在 router

manifest 转对象的过程中，怎么动态引入？

*   问题2:
    

写死 import 里的路径尝试，发现 createServerRoutes 函数出问题，因为里面的 RouteComponent 组件，内部会读取 useAppContext，而报错的表现是这个 context 里面没东西

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/1192f360c26a4a34b2026012ca0e986a3180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/26776b17e0be4833bdbb950f043a1e913180.png)

发现没东西是因为 没有给 context 加 routeModules，但是加完还是 {}

*   问题3
    

写在开发代码里的 rscServerRouter 虽然加了 use client，但是被 runServerApp 引用后，运行的表现还是服务端组件，bundle 也没有传给浏览器

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/6459ed0467b64a1a9616d0ff3af735e43180.png)

### 8.15-8.17

猜测 use client/server 不生效时因为漏了写服务端代码编译

重写服务端代码编译逻辑，把运行时的 register() 转到 ice 中用 esbuild 的插件写编译逻辑，产物在 build/server 里。

**问题**：routes-config.bundle.mjs 文件不应该被处理，里面的内容不应该被我的编译插件改变，但这里的逻辑好像在 config.js 里，不在 esbuild 里控制

但目前项目可以 build 和 run，

虽然改变了，但还是可以运行的

### 8.18

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/96c7d78103154dc0b4d50fc5faca020d3180.png)

运行报错，发现是传入的这个组件，在 react.createElement 后的结果中，type 为 undefined，正常应该是 function

发现这个 rscServerRouter 传过来就是 undefined的，忘记以前是什么情况了，但原因就是这个组件没传过来

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/4457c2f8ec48449b81a38b7e859672e23180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/58f3c03bd9c84a5ba492caf71f81d8033180.png)

貌似是引入有问题

**发现**是文件编译转化逻辑导致的，可能最终的代码不一样了，看看怎么搞。（验证过程：如果把 rscServerRouter 的 use sever 删掉，就可以被正常引入；如果在这个组件中包含客户端组件，则这个客户端组件也找不到导出。）

对比 build 文件，参照没加 esbuild 编译逻辑的 build，和 加了编译逻辑的（没在 rscServerERouter里引入testClient，否则会报错引入错误）。

发现前者是有这个 chunk 的，而后者少了这个。另外还有一个问题，后者的每个文件里，没有 export，但加了就报错，不知道原因

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/78fe2c91c26548f8b3f4baeefed960023180.png)

### 8.21 

解决上面的问题：给编译输出逻辑加了一个逻辑判断，主要还是模块导出的问题。之前忽略了 pages 文件 和 components 文件的区别，pages 文件编译后的导出应是 export {pageConfig}，components 文件编译的结果是这个文件的render函数 export default comp;，就可以解决上述报错。

**新问题**：1

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/fd1efea7d950405ea689cf85974453bd3180.png)

已经能够输出包含引用客户端组件的 json 数据，但是 chunks 内的 id 对应的文件内容有误，实际返回的 891.js 是一个疑似 documennt.js 的 html 文件，而不是 js，所以解析错误。

问题2:

build 的时候，编译产物的文件是预期中的结果：![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/02f4c45d20854d7287a20f49fb7c7d8a3180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/2f2ec618d7644aeb89630b0ed3941f3d3180.png)

，但 start 后，产物文件内容改变

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/baf5b811340c49888bc62df3db61a91c3180.png)

build 和 start 逻辑不同？是不是我只在 serverCompiler 里面加的是 build 的逻辑，而 start 的逻辑没加？

### 8.22

**问题解决**：发现昨天问题2，run start编译结果被改变的原因是，ninjia这个vscode插件改变了编译内容。删掉插件和缓存即可。

由于编译内容被改变，build/server 下的 mjs 文件还是原本组件代码的内容，所以没有出现今天新问题1的报错，而昨天的问题1的chunk错误可能和这里有关

新问题：

1、由于编译转换，组件导出的function（即 pageConfig）被 proxy 代理成了对象，而 runAppServer 里有 pageConfig() 执行函数的写法，因此执行报错。

*   一种想法是，pageConfig 当作函数执行在 rsc 的场景下可能没必要执行，所以判断 pageConfig 如果是 proxy 就跳过![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/bcd5385c57074c4098f66f2d909666523180.png)
    

跳过后，回到了昨天问题1的状态，有 json 结构，但是 client 引用的 chunk 错误。

*   第二种（没试过）是尝试下不编译（走回头路了应该不太行）
    
*   第三种是发现，原本 layout 等 page 文件，里面有 export default 的 jsx 函数，还有 export 一个 pageConfig 的函数，然而我在代理时直接一并代理为一个对象了，是不是有问题，能不能分开，分开有什么变化；此外就是这些 page 组件是不是应该 打上 use xxx的标记，不打是不是可以的
    
*   debug 发现应该不是插件的问题，而是在 rsc 请求返回 json后，chunk.js 返回的内容出错，这个内容返回好像不是在插件里做的，看看是在 runServerApp 的哪里做的？是在这里做的吗
    
*   ![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/19e78a8987d441ff9a1b99a38a3ba2883180.png)
    

**发现问题**原因，在请求 bundle 时，请求的是它的路径，但是这里没有处理这个的逻辑，所以走的是csr的返回html。此外，/js/498.js 在build目录下并没有生成，实际对应的应该是 client3.js，所以和官方demo使用同一个插件，为什么生成 json 时这里的 chunkId 和 id 不同？（官方是路径名和 clien\[index\].js，我现在直接是 int 的 id 值）。

### 8.23

*   再次**发现原因**，就是在插件生成 rsc-client-manifest.json 时，内容就有出入了![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/NpQlKzzez4zLODvL/bc2916de-ac45-4065-8045-6b6e31383f03)，然而这是插件处理的，而插件和官方demo一模一样，是什么导致了 manifest 内容与 chunks 文件名不一致？    
    
*   start 方面，manifest 等产物是在内存里的，不从文件读，可以模仿 assets- manifest 写一个虚拟模块，直接传到 runServerApp 里的消费的函数里，这样内容是正常的
    
*   build 方面，猜测可能是 webpack 版本和官方 demo 的不同，我们的是 5.86 版本。chunks 名称是由 webpack 本身提供的，所以可能和插件本身无关
    
    *   此外如果不是 webpack 版本问题，就自己重写一个插件，用在dev环境时用 name 去替代 chunks 的值 而不是用 id
        

### 8.24

**问题**：在解析返回的chunks时，先是正常发送了 json 数据，页面loading，

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/NpQlKzzez4zLODvL/f464d350-1bc1-4242-af22-f3ca9903d76f)

然后在解析时报错：

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/6aacc7578c29455d9c05598bd80994b83180.png)

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/931f5028bf39445b99c9a2ca152527323180.png)

怀疑时这里返回的是 module 而不是组件 function 而报错

周会：

发现之前引入客户端组件，demo就不能work的原因：缺少了服务端编译的逻辑，

官方demo在运行时有一个register函数做了这个编译，但是在ice里面需要在编译时做，于是写了一个 esbuild 插件。后续遇到两个问题，编译结果不符合预期，发现xx

第二个是build阶段rsc的数据与bundle名称对应不上，后续可能要自己重写一下官方的插件

逻辑兼容问题

### 8.31

*   降级 react 依赖版本，引入了 use（其实不降级应该也可以，试验一下）
    

还是渲染client 组件报的组件错误，初步定位到这段逻辑

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/890d1777dd474999a5733b24169f3b3f3180.png)

### 9.4

*   跑通了项目，解决了之前组件类型错误的问题，根源在于 esbuild 代码转换逻辑中的，模块导入导出应该使用 cjs 而不是 esm ​![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/f533b13e40ce4de187ef06541878ff1e3180.png)
    

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/664a334d51b34836a07750d72f2747c63180.png)

在把 react-server-dom-webpack 升级到 23年8月份版本后，cerateClientModuleProxy 等两个函数可以直接从 server.node 中导入了。不过要改成 cjs 的导出方式。不过，在转换 server 端代码时，处理 import 导入的语句时，不需要转换成 cjs 的方式，直接拼接上源代码的 esm 的即可：

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/0ea03c29a34e4f93994b7af4b192cf983180.png)

因为后续会再编译一次，cjs 的方式在 build/server/index 下会通过一个 \_\_toESM 函数转换，所以可以混用

效果：

![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/42cf33d2fac84e5fb1ee64204895ceeb3180.png)

*   rscServerRegister 完善：
    
    *   server 组件的导入语句处理
        
    *   server 组件如果有函数导出，也处理
        
    *   server 组件在 export 函数外定义的全局变量，也不用特殊处理
        
    *   client 组件的导入导出不用特殊处理，试过都是可以调用到的（client 调 client）
        
*   问题：
    
    *   水兰的项目，server 组件没有编译产物？
        

### 9.5

*   在官方 demo 验证 createServerContext 可以给 server/client 组件传值
    

### 9.6

*   整理代码，完善 rscServerRegister 代码，但还不能处理 ts/tsx 语法
    
*   在自己 demo 验证 createServerContext 可以给 server/client 组件传值 ​![image](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/Rw352krzGck20W1J/eb371d200431463c8c3958d83a8394c23180.png)
    
*   但在水蓝的 feat-rsc 中用同样的方法没法从 server 传给 client 组件
    
*   todo：验证下自己的 demo 里用普通的 appContext 是不是能从 server 传 client？
    
*   todo：解决一下不能编译 ts/tsx 的问题
    

### 9.8 

*   验证了自己的 demo 里用普通的 appContext 能从 server 传 client？
    
*   解决了不能编译 ts/tsx 的问题
    

### 9.11

*   发现 rscServerRegister bug，server 组件自身引用了自己没 export 的函数，报错没 define，因为没在代码转换时保留不是 export 的函数
    
*   已修复
    

### 9.12

*   验证 feat-rsc 和 feat-rsc-router 里，发送请求获取数据的链路，前者没问题，后者会因为 server 组件放到了 router-dom 中，而使组件渲染2次，数据也发送了2次。
    
*   研究单测，以及如何写 rscServerRegister 的单测
    

### 9.13

*   完成单测，解决冲突，提交代码
    

todo：

*   [ ] 电脑文档备份、项目备份
    
*   [ ] 组内文档再看一遍，了解一下
    
*   [ ] 周报补